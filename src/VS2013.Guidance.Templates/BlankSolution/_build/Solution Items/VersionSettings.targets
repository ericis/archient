<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- IMPORTANT NOTE! After you change a value in this file, you will have to close and reopen the solution for the change to take effect. -->
  <PropertyGroup>
    <!--
            Define the version information for this solution. Theses properties are used by TFSBuildNumber.targets.
            A semantic versioning approach is recommended (major.minor.patch).
            Semantic versioning: http://semver.org/
            Versioning in NuGet: http://docs.nuget.org/docs/Reference/Versioning
        
            The major component is incremented for breaking changes or significant functional revisions. No backward compatibility promises.
            The minor component is incremented for new features and is backward compatible with previous releases for same major version.
            The patch component is for off-cycle releases (hot fixes, critical bug fixes, etc.) and is backward compatible for same major version.
    -->
    <TFSMajorBuildNumber>$majorversion$</TFSMajorBuildNumber>
    <TFSMinorBuildNumber>$minorversion$</TFSMinorBuildNumber>
    <!-- 
            Omitting the patch number will default it to an autogenerated value of $(TFSBuildYear2)$(TFSBuildDayOfYear3)
            Note that you may also need to change the default assignments in VersionAssignments.targets to ensure the expected version is
            populated in either of the AssemblyVersionString, AssemblyFileVersionString, and/or AssemblyInformationalVersionString properties.
    -->
    $if$ ($patchversion$ > 0)<TFSPatchBuildNumber>$patchversion$</TFSPatchBuildNumber>$else$<TFSPatchBuildNumber></TFSPatchBuildNumber>$endif$

    <!-- Calendar-based versioning can be aligned with planned product releases (e.g., year and month). Default is today's date. -->
    <!--<CalendarVersionBaseDate>2013-08-27</CalendarVersionBaseDate>-->

    <!-- You may customize where the version information code files are generated. -->
    <!--<SharedVersionOutputDirectory>$([System.IO.Path]::Combine($(SolutionDir), ".build"))</SharedVersionOutputDirectory>-->

    <!--
            Code generation works in one of two available modes.
            RemoveGeneratedFilesAfterBuild=false (default and recommended):
              Generated code files are created or overwritten prior to each build and remain after the build completes. Choose this option if
              you want to see the generated code and to avoid potential synchronization issues with multiple project solutions where each project
              is sharing the generated code files. Synchronization issues can occur when parallel project builds happen. Checking the generated
              code files into source control is not recommended because TFS Build will probably encounter permissions errors when attempting
              to overwrite the source controlled generated code files on disk.
            RemoveGeneratedFilesAfterBuild=true: 
              You may choose to remove the generated files after each build and have them recreated on each build. Choose this option if you
              encounter issues overwriting the files on each build (you get errors before a build). Removing the files will also prevent them
              from getting checked in to source control if that is what you wish. If checked in, the build will attempt to remove the readonly
              attribute and overwrite the generated files. If the build is unsuccessful in doing this, you may get a build error/permissions error
              as the code generation support will not be able to overwrite the source controlled files. This typically happens on TFS Builds as
              opposed to local developer builds. If you encounter this, you should remove the generated file(s) from source control and enable
              the removal behavior (set remove option to true).
        -->
    <!--<RemoveGeneratedFilesAfterBuild>true</RemoveGeneratedFilesAfterBuild>-->

    <!--
            Enable/disable code generation by output type/language as desired. By default, only C# code generation is enabled. A C# code file
            named AssemblyVersionInfo.cs will be generated by default. Here's an example of the output in that file:
        
            // <auto-generated/>
            // This file auto generated by TFS Build Number targets.
            // Brought to you by the numbers 1 and 2.
            using System.Reflection;

            [assembly: AssemblyTitle("Developer Build_20130503_17844RWA-293")]  // TFS branch/environment build info or local developer build info
            [assembly: AssemblyVersion("1.2.0.0")]          // 1=major, 2=minor, 0=patch/build and revision # (recommend keeping these 0)
            [assembly: AssemblyFileVersion("1.2.1305.3")]   // 13=year 2013, 05=month May, 65534=developer build fixed revision #
            [assembly: AssemblyInformationalVersion("1.2.3-alphadev0503")] // Semantic version 1=major, 2=minor, 3=patch + 4th component for TFS rev or dev build
        -->
    <!-- C# file output -->
    <!--<EnableCSharpCodeGeneration>true</EnableCSharpCodeGeneration>-->
    <!-- Visual Basic file output -->
    <!--<EnableVBCodeGeneration>true</EnableVBCodeGeneration>-->
    <!-- C++ file output (also produces a .h header file) -->
    <!--<EnableCPPCodeGeneration>true</EnableCPPCodeGeneration>-->
    <!-- WiX XML setup file output -->
    <!--<EnableWiXCodeGeneration>true</EnableWiXCodeGeneration>-->
    <!-- Plain text file output -->
    <!--<EnableTextCodeGeneration>true</EnableTextCodeGeneration>-->

    <!-- TFS Team Build version - 2010 is default but Dev11 is also supported -->
    <!--<TeamBuildVersion>Dev11</TeamBuildVersion>-->

    <!-- Folder name where build scripts are located -->
    <BuildScriptsFolderName>$commonfoldername$</BuildScriptsFolderName>
    
    <!-- Write out the version files as needed before the build -->
    <BuildDependsOn>
      TFSBuildFileVersion;
      WriteSharedCSharpAssemblyVersionFile;
      WriteSharedVBAssemblyVersionFile;
      WriteSharedCPPAssemblyVersionFile;
      WriteSharedTextAssemblyVersionFile;
      WriteSharedWiXAssemblyVersionFile;
      $(BuildDependsOn);
    </BuildDependsOn>

    <!-- Clean up the version files as needed after the build -->
    <BuildDependsOn>
      $(BuildDependsOn);
      AfterBuildSharedAssemblyVersionFiles;
    </BuildDependsOn>
  </PropertyGroup>

  <Import Project="TFSBuildNumber.targets" />
  <Import Project="VersionAssignments.targets" />
</Project>